\documentclass[a4paper]{article}
% \usepackage{xltxtra}
\usepackage[BoldFont, SlantFont, CJKchecksingle]{xeCJK}
\setCJKmainfont[Mapping=tex-text]{WenQuanYi Micro Hei}
\title{knn CUDA program design document}
\author{袁帥}
\date{}

\begin{document}
\maketitle

\section{Used resources}
我用到兩個kernel function,其中computeDist函式計算所有兩個點之間的距離平方值、並存入矩陣D中,knn函式根據D去計算每個點的k個最小的距離平方值並找出對應的點.

computeDist函式主要用到以下resources:
\begin{itemize}
  \item $m \times m$個2-D blocks, block(i, j)分別負責計算點i和點j之間的距離平方值.
  \item 每個block用到$n$個1-D threads, block(i, j)中的thread(k)負責計算點i和點j在第k維度的距離平方值.由於$n \in [0, 1000]$, 所以這麼設計不會超過max number of threads/block.
  \item 每個block用到大小爲$n \times sizeof(int)$的shared memory, block(i, j)的shared memory存放點i和點j在n個維度上的距離平方值. 由於我用到parallel reduction來對這些值求和,需要經常access,所以把它們放到shared memory中.同樣由於n的取值較小,不會超出每個block的shared memory size.
\end{itemize}

knn函式主要用到以下resources:
\begin{itemize}
  \item $m$個1-D blocks, block(i)分別負責求出點i的k nearest neighbors.
  \item 每個block用到$m$個1-D threads, block(i)中的thread(j)負責把點i到其他點的距離平方值從global memory中load進shared memory.由於$m \in [10, 1000]$, 所以這麼設計不會超過max number of threads/block.
  \item 每個block用到大小爲$m \times sizeof(int)$的shared memory, block(i)的shared memory存放點i到其他點的距離平方值.這是因爲對每個點來說,求k nearest neighbors只需要這m個值,而且這些值經常要被access,所以我把它們放到shared memory中.同樣由於n的取值較小,不會超出每個block的shared memory size.
\end{itemize}
\section{Details of implementation}
\begin{enumerate}
  \item computeDist求兩點之間的距離平方值.由於$D_{i,j} = D_{j,i}$, 而且我們在本問題不考慮點到自身的情況,所以只需對$i > j$的情況進行運算就可以了.滿足$i > j$的block(i, j)裏的n個thread先分別去算n個dimension的距離平方值,再通過parallel reduction的方式求和.之後處理n爲奇數parallel reduction漏算一個元素的問題.最後把結果write back到global memory的D中.考慮寫入global memory速度較慢,因此重複的$D_{i,j}$和$D_{j,i}$也只寫一項.
  \item 呼叫cudaDeviceSynchronize(),保證每個block已經執行完computeDist這個kernel function,此時所有點與點之間的距離平方值已完全寫入到D中.
  \item 對每個點,把它到其他(m-1)個點的距離平方值從global memory的D中load進每個點相應block的shared memory.如上所述,D中不存放冗餘信息,所以當$i < j$時需要將$i,j$互調來找到正確的$D_{i, j}$ (即$D_{j, i}$).
  \item 讓每個block的第一個thread來找k個最小值並把相應的index寫到out中.
\end{enumerate}
\section{Improvement}
我想到了幾種可能可以進一步改進的方法:
\begin{itemize}
  \item 求k個最小值的部分可以再用一次parallel reduction.不過求完前$(x-1)$個最小值後求第$x$個最小值時,需要把D的內容再重新load進shared memory中,這部分可能反而會降低performance.同時index需要額外的memory來存放,而且由於題目要求兩個距離相等時選擇二者index小的那個,所以在parallel reduction中也需要在距離相等時繼續對index進行比較.這些問題或許有改進的parallel reduction可以解決.
  \item 存放k nearest neighbors的index的out,由於在k次iteration中也需要被access以確保前面求出的最近鄰居不會再次出現,所以也可以先放到shared memory中,再寫回到global memory.
  \item 對於爲了去掉$D_{i, j} = D_{j, i}$冗餘而引起的$i > j$的block(i ,j)閒置的skew workload問題,可以通過只分配$m(m-1)/2$而非$m \times m$個block來解決,這需要重新讓block(i, j)對應到正確的兩個點上(此時已不一定是對應到點i和點j!),不過對於程式執行時間並沒有提升.
\end{itemize}
\end{document}
